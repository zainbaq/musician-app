{"version":3,"file":"microphone-js.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState: AudioState = {\n  leftChan: [],\n  rightChan: [],\n  recordingLength: 0,\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = { ...initialState };\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = { ...initialState };\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","writeUTFBytes","view","str","split","map","_","index","charCodeAt","forEach","value","idx","setUint8","initialState","leftChan","rightChan","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","getBlob","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","stop","getTracks","track","disconnect","leftChannel","leftChanData","rightChanData","downsampled","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","downsampleBuffer","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","encodeWav","reset","download","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}